#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bot Telegram Theo D√µi Gi√° B·∫°c - Railway Version
"""

import asyncio
import logging
import os
import re
import threading
from datetime import datetime, timedelta
from typing import Dict, Tuple

import requests
import pytz
from bs4 import BeautifulSoup
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler

# C·∫•u h√¨nh logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# C·∫•u h√¨nh
BOT_TOKEN = os.getenv('BOT_TOKEN', 'YOUR_BOT_TOKEN_HERE')
GROUP_CHAT_ID = os.getenv('GROUP_CHAT_ID', 'YOUR_GROUP_CHAT_ID')
PRICE_URL = "https://giabac.phuquygroup.vn/"
VN_TZ = pytz.timezone('Asia/Ho_Chi_Minh')
PORT = int(os.environ.get('PORT', 8000))

class SilverPriceBot:
    def __init__(self):
        self.price_history = []
        self.subscribers = set()
        self.last_prices = {}
        self.application = None
        
    async def fetch_silver_prices(self) -> Dict:
        """L·∫•y gi√° b·∫°c t·ª´ website"""
        try:
            loop = asyncio.get_event_loop()
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            response = await loop.run_in_executor(
                None, 
                lambda: requests.get(PRICE_URL, headers=headers, timeout=15)
            )
            
            if response.status_code == 200:
                return self.parse_silver_prices(response.text)
            else:
                logger.error(f"HTTP {response.status_code}")
                return {}
                
        except Exception as e:
            logger.error(f"Fetch error: {e}")
            return {}
    
    def parse_silver_prices(self, html: str) -> Dict:
        """Parse gi√° b·∫°c"""
        try:
            soup = BeautifulSoup(html, 'html.parser')
            prices = {}
            table_rows = soup.find_all('tr')
            
            for row in table_rows:
                cells = row.find_all('td')
                if len(cells) >= 4:
                    product = cells[0].get_text(strip=True)
                    unit = cells[1].get_text(strip=True)
                    buy_price = cells[2].get_text(strip=True)
                    sell_price = cells[3].get_text(strip=True)
                    
                    if buy_price and 'B·∫†C' in product.upper():
                        buy_price_num = self.parse_price(buy_price)
                        sell_price_num = self.parse_price(sell_price)
                        
                        if buy_price_num > 0:
                            prices[product] = {
                                'buy_price': buy_price_num,
                                'sell_price': sell_price_num if sell_price_num > 0 else None,
                                'unit': unit,
                                'timestamp': datetime.now(VN_TZ)
                            }
            
            return prices
        except Exception as e:
            logger.error(f"Parse error: {e}")
            return {}
    
    def parse_price(self, price_str: str) -> int:
        if not price_str or price_str == '-':
            return 0
        numbers = re.findall(r'\d+', price_str.replace(',', '').replace('.', ''))
        return int(''.join(numbers)) if numbers else 0
    
    def format_price(self, price: int) -> str:
        return f"{price:,}".replace(',', '.')

bot = SilverPriceBot()

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start command"""
    await update.message.reply_text(
        "üè¶ *Bot Gi√° B·∫°c Railway*\n\n"
        "üìã Commands:\n"
        "‚Ä¢ /price - Gi√° hi·ªán t·∫°i\n"
        "‚Ä¢ /subscribe - ƒêƒÉng k√Ω th√¥ng b√°o\n"
        "‚Ä¢ /status - Tr·∫°ng th√°i bot",
        parse_mode='Markdown'
    )

async def get_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Get current price"""
    await update.message.reply_text("üîÑ ƒêang l·∫•y gi√°...")
    
    prices = await bot.fetch_silver_prices()
    
    if prices:
        message = "üí∞ *GI√Å B·∫†C*\n\n"
        for product, data in list(prices.items())[:3]:  # Top 3 products
            message += f"üî∏ {product[:30]}...\n" if len(product) > 30 else f"üî∏ {product}\n"
            message += f"üíµ Mua: {bot.format_price(data['buy_price'])} VND\n"
            if data['sell_price']:
                message += f"üí¥ B√°n: {bot.format_price(data['sell_price'])} VND\n"
            message += "\n"
        
        message += f"üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m')}"
        await update.message.reply_text(message, parse_mode='Markdown')
    else:
        await update.message.reply_text("‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu")

async def subscribe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Subscribe to notifications"""
    user_id = update.effective_user.id
    bot.subscribers.add(user_id)
    await update.message.reply_text("üîî ƒê√£ ƒëƒÉng k√Ω!")

async def get_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Bot status"""
    await update.message.reply_text(
        f"ü§ñ Bot ƒëang ch·∫°y\n"
        f"üìä {len(bot.price_history)} records\n"
        f"üë• {len(bot.subscribers)} subscribers\n"
        f"üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m')}"
    )

# Health check server
from aiohttp import web

async def health_handler(request):
    """Health check endpoint"""
    return web.Response(
        text=f"OK - Bot running at {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}"
    )

async def root_handler(request):
    """Root endpoint"""
    status = {
        'status': 'running',
        'bot_name': 'Silver Price Bot',
        'timestamp': datetime.now(VN_TZ).isoformat(),
        'subscribers': len(bot.subscribers),
        'price_records': len(bot.price_history)
    }
    return web.json_response(status)

def create_web_app():
    """T·∫°o web app cho health check"""
    app = web.Application()
    app.router.add_get('/', root_handler)
    app.router.add_get('/health', health_handler)
    app.router.add_get('/status', root_handler)
    return app

async def monitoring_loop():
    """Background task theo d√µi gi√°"""
    logger.info("üîÑ Starting price monitoring...")
    
    while True:
        try:
            prices = await bot.fetch_silver_prices()
            
            if prices:
                # L∆∞u l·ªãch s·ª≠
                bot.price_history.append({
                    'timestamp': datetime.now(VN_TZ),
                    'prices': prices
                })
                
                # Gi·ªØ 50 b·∫£n ghi g·∫ßn nh·∫•t
                if len(bot.price_history) > 50:
                    bot.price_history = bot.price_history[-50:]
                
                # Ki·ªÉm tra thay ƒë·ªïi l·ªõn
                main_product = "B·∫†C MI·∫æNG PH√ö QU√ù 999 1 L∆Ø·ª¢NG"
                if (main_product in prices and main_product in bot.last_prices):
                    current = prices[main_product]['buy_price']
                    last = bot.last_prices[main_product]['buy_price']
                    change_percent = abs((current - last) / last * 100)
                    
                    if change_percent > 2.0:
                        change = current - last
                        emoji = "üìà" if change > 0 else "üìâ"
                        
                        alert = f"""
üö® *C·∫¢NH B√ÅO GI√Å B·∫†C*

{emoji} Gi√° thay ƒë·ªïi {change_percent:.2f}%
üí∞ {bot.format_price(current)} VND
üìä {'+' if change > 0 else ''}{bot.format_price(change)} VND

üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m')}
                        """
                        
                        # G·ª≠i c·∫£nh b√°o
                        if GROUP_CHAT_ID and GROUP_CHAT_ID != 'YOUR_GROUP_CHAT_ID':
                            try:
                                await bot.application.bot.send_message(
                                    chat_id=GROUP_CHAT_ID,
                                    text=alert,
                                    parse_mode='Markdown'
                                )
                            except Exception as e:
                                logger.error(f"Group send error: {e}")
                
                bot.last_prices = prices
                logger.info(f"‚úÖ Updated prices - {len(prices)} products")
            
            else:
                logger.warning("‚ö†Ô∏è No price data")
            
            # Ch·ªù 30 ph√∫t
            await asyncio.sleep(30 * 60)
            
        except Exception as e:
            logger.error(f"Monitoring error: {e}")
            await asyncio.sleep(60)

async def main():
    """Main function"""
    # Validate config
    if BOT_TOKEN == 'YOUR_BOT_TOKEN_HERE':
        logger.error("‚ùå BOT_TOKEN not configured!")
        return
    
    logger.info("üöÄ Starting Silver Price Bot...")
    
    # Create Telegram app
    application = Application.builder().token(BOT_TOKEN).build()
    bot.application = application
    
    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("price", get_price))
    application.add_handler(CommandHandler("subscribe", subscribe))
    application.add_handler(CommandHandler("status", get_status))
    
    # Create web app for health checks
    web_app = create_web_app()
    runner = web.AppRunner(web_app)
    await runner.setup()
    
    # Start web server
    site = web.TCPSite(runner, '0.0.0.0', PORT)
    await site.start()
    logger.info(f"üåê Health server started on port {PORT}")
    
    # Start monitoring in background
    monitoring_task = asyncio.create_task(monitoring_loop())
    
    # Start telegram bot
    logger.info("ü§ñ Starting Telegram bot...")
    await application.initialize()
    await application.start()
    await application.updater.start_polling(drop_pending_updates=True)
    
    # Keep running
    try:
        await asyncio.Future()  # Run forever
    except KeyboardInterrupt:
        logger.info("üõë Shutting down...")
    finally:
        await application.stop()
        monitoring_task.cancel()

if __name__ == '__main__':
    asyncio.run(main()) requests
import pytz
from bs4 import BeautifulSoup
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler

# C·∫•u h√¨nh logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# C·∫•u h√¨nh t·ª´ environment variables
BOT_TOKEN = os.getenv('BOT_TOKEN', 'YOUR_BOT_TOKEN_HERE')
GROUP_CHAT_ID = os.getenv('GROUP_CHAT_ID', 'YOUR_GROUP_CHAT_ID')
PRICE_URL = "https://giabac.phuquygroup.vn/"
VN_TZ = pytz.timezone('Asia/Ho_Chi_Minh')

# Port cho Railway/Render
PORT = int(os.environ.get('PORT', 8000))

class SilverPriceBot:
    def __init__(self):
        self.price_history = []
        self.subscribers = set()
        self.last_prices = {}
        self.application = None
        self.monitoring_task = None
        
    async def fetch_silver_prices(self) -> Dict:
        """L·∫•y gi√° b·∫°c t·ª´ website"""
        try:
            loop = asyncio.get_event_loop()
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'vi-VN,vi;q=0.9,en;q=0.8',
                'Connection': 'keep-alive',
            }
            
            response = await loop.run_in_executor(
                None, 
                lambda: requests.get(PRICE_URL, headers=headers, timeout=15)
            )
            
            if response.status_code == 200:
                logger.info("‚úÖ L·∫•y d·ªØ li·ªáu th√†nh c√¥ng")
                return self.parse_silver_prices(response.text)
            else:
                logger.error(f"‚ùå HTTP {response.status_code}")
                return {}
                
        except Exception as e:
            logger.error(f"‚ùå L·ªói fetch: {e}")
            return {}
    
    def parse_silver_prices(self, html: str) -> Dict:
        """Parse gi√° b·∫°c t·ª´ HTML"""
        try:
            soup = BeautifulSoup(html, 'html.parser')
            prices = {}
            table_rows = soup.find_all('tr')
            current_time = datetime.now(VN_TZ)
            
            for row in table_rows:
                cells = row.find_all('td')
                if len(cells) >= 4:
                    product = cells[0].get_text(strip=True)
                    unit = cells[1].get_text(strip=True)
                    buy_price = cells[2].get_text(strip=True)
                    sell_price = cells[3].get_text(strip=True)
                    
                    if buy_price and buy_price != '-' and 'B·∫†C' in product.upper():
                        buy_price_num = self.parse_price(buy_price)
                        sell_price_num = self.parse_price(sell_price)
                        
                        if buy_price_num > 0:
                            prices[product] = {
                                'unit': unit,
                                'buy_price': buy_price_num,
                                'sell_price': sell_price_num if sell_price_num > 0 else None,
                                'buy_price_str': buy_price,
                                'sell_price_str': sell_price if sell_price != '-' else 'Kh√¥ng mua',
                                'timestamp': current_time
                            }
            
            logger.info(f"üìä Parse ƒë∆∞·ª£c {len(prices)} s·∫£n ph·∫©m")
            return prices
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói parse: {e}")
            return {}
    
    def parse_price(self, price_str: str) -> int:
        """Chuy·ªÉn ƒë·ªïi chu·ªói gi√° th√†nh s·ªë"""
        if not price_str or price_str == '-':
            return 0
        numbers = re.findall(r'\d+', price_str.replace(',', '').replace('.', ''))
        return int(''.join(numbers)) if numbers else 0
    
    def format_price(self, price: int) -> str:
        """Format gi√° v·ªõi d·∫•u ph·∫©y"""
        return f"{price:,}".replace(',', '.')
    
    def calculate_spread(self, buy_price: int, sell_price: int) -> Tuple[int, float]:
        """T√≠nh ch√™nh l·ªách gi√° mua b√°n"""
        if sell_price and sell_price > 0:
            spread = sell_price - buy_price
            spread_percent = (spread / buy_price) * 100 if buy_price > 0 else 0
            return spread, spread_percent
        return 0, 0.0
    
    async def send_to_group(self, message: str):
        """G·ª≠i tin nh·∫Øn ƒë·∫øn group"""
        if GROUP_CHAT_ID and GROUP_CHAT_ID != 'YOUR_GROUP_CHAT_ID' and self.application:
            try:
                await self.application.bot.send_message(
                    chat_id=GROUP_CHAT_ID,
                    text=message,
                    parse_mode='Markdown'
                )
                logger.info(f"‚úÖ ƒê√£ g·ª≠i tin ƒë·∫øn group")
            except Exception as e:
                logger.error(f"‚ùå L·ªói g·ª≠i group: {e}")
    
    async def price_monitoring_loop(self):
        """V√≤ng l·∫∑p theo d√µi gi√°"""
        logger.info("üîÑ B·∫Øt ƒë·∫ßu monitoring gi√°...")
        
        while True:
            try:
                # L·∫•y gi√° m·ªõi
                prices = await self.fetch_silver_prices()
                
                if prices:
                    # L∆∞u l·ªãch s·ª≠
                    self.price_history.append({
                        'timestamp': datetime.now(VN_TZ),
                        'prices': prices.copy()
                    })
                    
                    # Gi·ªØ ch·ªâ 100 b·∫£n ghi
                    if len(self.price_history) > 100:
                        self.price_history = self.price_history[-100:]
                    
                    # Ki·ªÉm tra thay ƒë·ªïi l·ªõn
                    await self.check_price_alerts(prices)
                    
                    # Ki·ªÉm tra n·∫øu ƒë·∫øn gi·ªù g·ª≠i tin ƒë·ªãnh k·ª≥
                    await self.check_scheduled_updates(prices)
                    
                    # C·∫≠p nh·∫≠t gi√° cu·ªëi
                    self.last_prices = prices.copy()
                    
                else:
                    logger.warning("‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu gi√°")
                
                # Ch·ªù 30 ph√∫t
                await asyncio.sleep(30 * 60)
                
            except Exception as e:
                logger.error(f"‚ùå L·ªói trong monitoring loop: {e}")
                await asyncio.sleep(60)  # Ch·ªù 1 ph√∫t n·∫øu l·ªói
    
    async def check_price_alerts(self, current_prices: Dict):
        """Ki·ªÉm tra c·∫£nh b√°o thay ƒë·ªïi gi√°"""
        main_product = "B·∫†C MI·∫æNG PH√ö QU√ù 999 1 L∆Ø·ª¢NG"
        
        if (main_product in current_prices and 
            main_product in self.last_prices):
            
            current_price = current_prices[main_product]['buy_price']
            last_price = self.last_prices[main_product]['buy_price']
            
            change_percent = abs((current_price - last_price) / last_price * 100)
            
            if change_percent > 2.0:
                change = current_price - last_price
                change_emoji = "üìà" if change > 0 else "üìâ"
                
                alert_message = f"""
üö® *C·∫¢NH B√ÅO THAY ƒê·ªîI GI√Å B·∫†C*

{change_emoji} *{main_product}*

üìä Gi√° c≈©: {self.format_price(last_price)} VND
üìä Gi√° m·ªõi: {self.format_price(current_price)} VND
üìà Thay ƒë·ªïi: {'+' if change > 0 else ''}{self.format_price(change)} VND ({change_percent:+.2f}%)

üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}
                """
                
                await self.send_to_group(alert_message)
                
                # G·ª≠i cho subscribers c√° nh√¢n
                for user_id in self.subscribers.copy():
                    try:
                        await self.application.bot.send_message(
                            chat_id=user_id,
                            text=alert_message,
                            parse_mode='Markdown'
                        )
                    except Exception as e:
                        logger.error(f"‚ùå L·ªói g·ª≠i alert cho {user_id}: {e}")
                        self.subscribers.discard(user_id)
    
    async def check_scheduled_updates(self, prices: Dict):
        """Ki·ªÉm tra n·∫øu ƒë·∫øn gi·ªù g·ª≠i tin ƒë·ªãnh k·ª≥"""
        now = datetime.now(VN_TZ)
        
        # Ch·ªâ g·ª≠i v√†o c√°c th·ªùi ƒëi·ªÉm: 8:30, 12:00, 16:00
        target_times = [
            (8, 30), (12, 0), (16, 0)
        ]
        
        current_time = (now.hour, now.minute)
        
        # Ki·ªÉm tra n·∫øu ƒë√∫ng th·ªùi ƒëi·ªÉm (trong kho·∫£ng 5 ph√∫t)
        for target_hour, target_minute in target_times:
            time_diff = abs((now.hour * 60 + now.minute) - (target_hour * 60 + target_minute))
            
            if time_diff <= 2:  # Trong v√≤ng 2 ph√∫t
                await self.send_scheduled_update(prices)
                break
    
    async def send_scheduled_update(self, prices: Dict):
        """G·ª≠i c·∫≠p nh·∫≠t ƒë·ªãnh k·ª≥"""
        message = "üîî *C·∫¨P NH·∫¨T GI√Å B·∫†C ƒê·ªäNH K·ª≤*\n\n"
        
        main_products = [
            "B·∫†C MI·∫æNG PH√ö QU√ù 999 1 L∆Ø·ª¢NG",
            "B·∫†C TH·ªéI PH√ö QU√ù 999 10 L∆Ø·ª¢NG, 5 L∆Ø·ª¢NG"
        ]
        
        for product in main_products:
            if product in prices:
                data = prices[product]
                message += f"üî∏ *{product}*\n"
                message += f"   üíµ Mua: {self.format_price(data['buy_price'])} VND\n"
                
                if data['sell_price']:
                    message += f"   üí¥ B√°n: {self.format_price(data['sell_price'])} VND\n"
                    spread, spread_percent = self.calculate_spread(
                        data['buy_price'], data['sell_price']
                    )
                    message += f"   üìä Ch√™nh l·ªách: {self.format_price(spread)} VND ({spread_percent:.2f}%)\n"
                
                message += "\n"
        
        # T√≠nh bi·∫øn ƒë·ªông
        main_product = "B·∫†C MI·∫æNG PH√ö QU√ù 999 1 L∆Ø·ª¢NG"
        if (main_product in prices and main_product in self.last_prices):
            current_price = prices[main_product]['buy_price']
            last_price = self.last_prices[main_product]['buy_price']
            change = current_price - last_price
            change_percent = (change / last_price * 100) if last_price > 0 else 0
            
            if abs(change_percent) > 0.1:
                change_emoji = "üìà" if change > 0 else "üìâ" if change < 0 else "‚û°Ô∏è"
                message += f"{change_emoji} *Bi·∫øn ƒë·ªông:* {'+' if change > 0 else ''}{self.format_price(change)} VND ({change_percent:+.2f}%)\n\n"
        
        message += f"üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}\n"
        message += f"üåê *Ngu·ªìn:* giabac.phuquygroup.vn"
        
        await self.send_to_group(message)

# Kh·ªüi t·∫°o bot
bot = SilverPriceBot()

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """L·ªánh /start"""
    welcome_text = """
üè¶ *Ch√†o m·ª´ng ƒë·∫øn v·ªõi Bot Gi√° B·∫°c!*

Bot theo d√µi gi√° b·∫°c t·ª´ Ph√∫ Qu√Ω Group 24/7

üìã *C√°c l·ªánh:*
‚Ä¢ /price - Gi√° hi·ªán t·∫°i
‚Ä¢ /history - L·ªãch s·ª≠ 24h
‚Ä¢ /subscribe - ƒêƒÉng k√Ω th√¥ng b√°o
‚Ä¢ /spread - Ch√™nh l·ªách gi√°
‚Ä¢ /status - Tr·∫°ng th√°i bot

üîÑ *T·ª± ƒë·ªông:*
‚Ä¢ C·∫≠p nh·∫≠t: 8:30, 12:00, 16:00
‚Ä¢ C·∫£nh b√°o thay ƒë·ªïi > 2%
    """
    
    keyboard = [
        [
            InlineKeyboardButton("üìà Gi√° hi·ªán t·∫°i", callback_data='price'),
            InlineKeyboardButton("üìä Ch√™nh l·ªách", callback_data='spread')
        ],
        [
            InlineKeyboardButton("üîî ƒêƒÉng k√Ω", callback_data='subscribe'),
            InlineKeyboardButton("üìö L·ªãch s·ª≠", callback_data='history')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(welcome_text, parse_mode='Markdown', reply_markup=reply_markup)

async def get_current_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """L·ªánh /price"""
    await update.message.reply_text("üîÑ ƒêang l·∫•y gi√°...")
    
    prices = await bot.fetch_silver_prices()
    
    if not prices:
        await update.message.reply_text("‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu. Ki·ªÉm tra k·∫øt n·ªëi.")
        return
    
    message = "üí∞ *GI√Å B·∫†C HI·ªÜN T·∫†I*\n\n"
    
    for product, data in prices.items():
        spread, spread_percent = bot.calculate_spread(
            data['buy_price'], 
            data['sell_price'] if data['sell_price'] else 0
        )
        
        message += f"üî∏ *{product}*\n"
        message += f"   üíµ Mua: {bot.format_price(data['buy_price'])} VND\n"
        
        if data['sell_price']:
            message += f"   üí¥ B√°n: {bot.format_price(data['sell_price'])} VND\n"
            message += f"   üìä Ch√™nh l·ªách: {bot.format_price(spread)} VND ({spread_percent:.2f}%)\n"
        
        message += "\n"
    
    message += f"üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}"
    
    await update.message.reply_text(message, parse_mode='Markdown')

async def subscribe_notifications(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ƒêƒÉng k√Ω th√¥ng b√°o"""
    user_id = update.effective_user.id
    bot.subscribers.add(user_id)
    
    await update.message.reply_text(
        "üîî *ƒêƒÉng k√Ω th√†nh c√¥ng!*\n\n"
        "Nh·∫≠n th√¥ng b√°o khi gi√° thay ƒë·ªïi > 2%",
        parse_mode='Markdown'
    )

async def unsubscribe_notifications(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """H·ªßy ƒëƒÉng k√Ω"""
    user_id = update.effective_user.id
    bot.subscribers.discard(user_id)
    await update.message.reply_text("üîï ƒê√£ h·ªßy ƒëƒÉng k√Ω!")

async def get_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ki·ªÉm tra tr·∫°ng th√°i bot"""
    status_message = f"""
ü§ñ *TR·∫†NG TH√ÅI BOT*

üîÑ Bot ƒëang ch·∫°y: ‚úÖ
üìä S·ªë l·ªãch s·ª≠: {len(bot.price_history)} b·∫£n ghi
üë• Subscribers: {len(bot.subscribers)} ng∆∞·ªùi
üïê Uptime: {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}

üåê Ngu·ªìn: giabac.phuquygroup.vn
üì° Hosting: Railway/Render
    """
    
    await update.message.reply_text(status_message, parse_mode='Markdown')

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω inline buttons"""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'price':
        await query.edit_message_text("üîÑ ƒêang l·∫•y gi√°...")
        prices = await bot.fetch_silver_prices()
        
        if prices:
            main_product = "B·∫†C MI·∫æNG PH√ö QU√ù 999 1 L∆Ø·ª¢NG"
            if main_product in prices:
                data = prices[main_product]
                message = f"""
üí∞ *GI√Å B·∫†C HI·ªÜN T·∫†I*

üî∏ *{main_product}*
üíµ Mua: {bot.format_price(data['buy_price'])} VND
üí¥ B√°n: {bot.format_price(data['sell_price'])} VND

üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}
                """
                await query.edit_message_text(message, parse_mode='Markdown')
        else:
            await query.edit_message_text("‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu")
    
    elif query.data == 'subscribe':
        user_id = query.from_user.id
        bot.subscribers.add(user_id)
        await query.edit_message_text("üîî ƒê√£ ƒëƒÉng k√Ω th√¥ng b√°o!")

async def keep_alive_server():
    """Server ƒë∆°n gi·∫£n ƒë·ªÉ keep Railway/Render alive"""
    from aiohttp import web
    
    async def health_check(request):
        return web.Response(
            text=f"ü§ñ Silver Price Bot is running!\n"
                 f"‚è∞ {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}\n"
                 f"üìä History: {len(bot.price_history)} records\n"
                 f"üë• Subscribers: {len(bot.subscribers)}"
        )
    
    app = web.Application()
    app.router.add_get('/', health_check)
    app.router.add_get('/health', health_check)
    
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', PORT)
    await site.start()
    
    logger.info(f"üåê Health server started on port {PORT}")

async def main():
    """H√†m ch√≠nh"""
    # Ki·ªÉm tra c·∫•u h√¨nh
    if BOT_TOKEN == 'YOUR_BOT_TOKEN_HERE':
        logger.error("‚ùå Ch∆∞a c·∫•u h√¨nh BOT_TOKEN!")
        print("üîß H√£y set environment variable: BOT_TOKEN=your_token_here")
        return
    
    # T·∫°o application
    application = Application.builder().token(BOT_TOKEN).build()
    bot.application = application
    
    # Th√™m handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("price", get_current_price))
    application.add_handler(CommandHandler("subscribe", subscribe_notifications))
    application.add_handler(CommandHandler("unsubscribe", unsubscribe_notifications))
    application.add_handler(CommandHandler("status", get_status))
    application.add_handler(CallbackQueryHandler(button_callback))
    
    # Kh·ªüi ƒë·ªông monitoring trong background
    bot.monitoring_task = asyncio.create_task(bot.price_monitoring_loop())
    
    # Kh·ªüi ƒë·ªông health server cho Railway/Render
    await keep_alive_server()
    
    logger.info("ü§ñ Bot Gi√° B·∫°c ƒëang kh·ªüi ƒë·ªông...")
    logger.info("üìä Ngu·ªìn: https://giabac.phuquygroup.vn/")
    logger.info(f"üåê Health server: http://0.0.0.0:{PORT}")
    
    # Ch·∫°y bot
    await application.run_polling(drop_pending_updates=True)

if __name__ == '__main__':
    asyncio.run(main())
