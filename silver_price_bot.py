#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bot Telegram Theo D√µi Gi√° B·∫°c - Railway Version (fixed async)
- Health server lu√¥n tr·∫£ 200 t·∫°i /health ƒë·ªÉ tr√°nh 503
- PTB v20.7 (polling, async-friendly)
- T√≠nh ch√™nh l·ªách (spread) gi·ªØa gi√° mua/b√°n
"""

import asyncio
import logging
import os
import re
from datetime import datetime
from typing import Dict, Tuple

import requests
import pytz
from bs4 import BeautifulSoup
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler

# ========= C·∫•u h√¨nh logging =========
logging.basicConfig(
    format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger("silver-bot")

# ========= Bi·∫øn m√¥i tr∆∞·ªùng / c·∫•u h√¨nh =========
BOT_TOKEN = os.getenv("BOT_TOKEN", "YOUR_BOT_TOKEN_HERE")
GROUP_CHAT_ID = os.getenv("GROUP_CHAT_ID", "YOUR_GROUP_CHAT_ID")
PRICE_URL = "https://giabac.phuquygroup.vn/"
VN_TZ = pytz.timezone("Asia/Ho_Chi_Minh")
PORT = int(os.environ.get("PORT", 8000))  # Railway cung c·∫•p PORT

# ========= Bot logic =========
class SilverPriceBot:
    def __init__(self):
        self.price_history = []   # list[{"timestamp": dt, "prices": {...}}]
        self.subscribers = set()  # user ids
        self.last_prices = {}     # map s·∫£n ph·∫©m -> dict gi√° l·∫ßn tr∆∞·ªõc
        self.application = None   # s·∫Ω g√°n khi t·∫°o Application
        self.monitoring_task = None

    async def fetch_silver_prices(self) -> Dict:
        """L·∫•y gi√° b·∫°c t·ª´ website."""
        try:
            loop = asyncio.get_event_loop()
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                              "AppleWebKit/537.36 (KHTML, like Gecko) "
                              "Chrome/120.0.0.0 Safari/537.36",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                "Accept-Language": "vi-VN,vi;q=0.9,en;q=0.8",
                "Connection": "keep-alive",
            }
            resp = await loop.run_in_executor(
                None, lambda: requests.get(PRICE_URL, headers=headers, timeout=15)
            )
            if resp.status_code == 200:
                return self.parse_silver_prices(resp.text)
            logger.error("HTTP %s khi l·∫•y gi√°", resp.status_code)
            return {}
        except Exception as e:
            logger.exception("Fetch error: %s", e)
            return {}

    def parse_silver_prices(self, html: str) -> Dict:
        """Parse gi√° t·ª´ HTML."""
        try:
            soup = BeautifulSoup(html, "html.parser")
            prices: Dict[str, Dict] = {}
            now = datetime.now(VN_TZ)

            for row in soup.find_all("tr"):
                tds = row.find_all("td")
                if len(tds) < 4:
                    continue
                product = tds[0].get_text(strip=True)
                unit = tds[1].get_text(strip=True)
                buy_raw = tds[2].get_text(strip=True)
                sell_raw = tds[3].get_text(strip=True)

                # Ch·ªâ l·∫•y c√°c d√≤ng c√≥ ch·ªØ "B·∫†C"
                if "B·∫†C" not in product.upper():
                    continue
                buy = self.parse_price(buy_raw)
                sell = self.parse_price(sell_raw)

                if buy > 0:
                    prices[product] = {
                        "unit": unit,
                        "buy_price": buy,
                        "sell_price": sell if sell > 0 else None,
                        "timestamp": now,
                    }

            logger.info("Parse ƒë∆∞·ª£c %d s·∫£n ph·∫©m", len(prices))
            return prices
        except Exception as e:
            logger.exception("Parse error: %s", e)
            return {}

    @staticmethod
    def parse_price(price_str: str) -> int:
        """Chuy·ªÉn chu·ªói gi√° th√†nh s·ªë nguy√™n VND."""
        if not price_str or price_str == "-":
            return 0
        # B·ªè d·∫•u ch·∫•m, ph·∫©y -> gi·ªØ s·ªë
        numbers = re.findall(r"\d+", price_str.replace(",", "").replace(".", ""))
        return int("".join(numbers)) if numbers else 0

    @staticmethod
    def format_price(price: int) -> str:
        """Format s·ªë theo 1.234.567"""
        return f"{price:,}".replace(",", ".")

    @staticmethod
    def calculate_spread(buy_price: int, sell_price: int | None) -> Tuple[int, float]:
        """T√≠nh ch√™nh l·ªách (b√°n - mua) & % theo mua."""
        if sell_price and sell_price > 0 and buy_price > 0:
            spread = sell_price - buy_price
            pct = (spread / buy_price) * 100
            return spread, pct
        return 0, 0.0

    async def send_to_group(self, message: str):
        """G·ª≠i tin t·ªõi GROUP_CHAT_ID n·∫øu c√≥."""
        if (
            GROUP_CHAT_ID
            and GROUP_CHAT_ID != "YOUR_GROUP_CHAT_ID"
            and self.application
        ):
            try:
                await self.application.bot.send_message(
                    chat_id=GROUP_CHAT_ID, text=message, parse_mode="Markdown"
                )
            except Exception as e:
                logger.error("L·ªói g·ª≠i group: %s", e)

    async def price_monitoring_loop(self):
        """V√≤ng l·∫∑p l·∫•y gi√°/ g·ª≠i c·∫£nh b√°o/ g·ª≠i ƒë·ªãnh k·ª≥."""
        logger.info("B·∫Øt ƒë·∫ßu monitoring gi√°...")
        while True:
            try:
                prices = await self.fetch_silver_prices()
                if prices:
                    # L∆∞u l·ªãch s·ª≠ (gi·ªõi h·∫°n 100)
                    self.price_history.append(
                        {"timestamp": datetime.now(VN_TZ), "prices": prices.copy()}
                    )
                    self.price_history = self.price_history[-100:]

                    # C·∫£nh b√°o thay ƒë·ªïi > 2% cho s·∫£n ph·∫©m ch√≠nh
                    await self.check_price_alerts(prices)
                    # G·ª≠i b·∫£ng tin ƒë·ªãnh k·ª≥ theo m·ªëc gi·ªù
                    await self.check_scheduled_updates(prices)

                    # L∆∞u last
                    self.last_prices = prices.copy()
                else:
                    logger.warning("Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu gi√°")

                await asyncio.sleep(30 * 60)  # 30 ph√∫t
            except Exception as e:
                logger.exception("L·ªói monitoring: %s", e)
                await asyncio.sleep(60)

    async def check_price_alerts(self, current_prices: Dict):
        """C·∫£nh b√°o n·∫øu bi·∫øn ƒë·ªông >2% ƒë·ªëi v·ªõi s·∫£n ph·∫©m ch√≠nh."""
        main_product = "B·∫†C MI·∫æNG PH√ö QU√ù 999 1 L∆Ø·ª¢NG"
        if main_product in current_prices and main_product in self.last_prices:
            cur = current_prices[main_product]["buy_price"]
            last = self.last_prices[main_product]["buy_price"]
            if last > 0:
                change_pct = abs((cur - last) / last * 100)
                if change_pct > 2.0:
                    delta = cur - last
                    emoji = "üìà" if delta > 0 else "üìâ"
                    msg = (
                        f"üö® *C·∫¢NH B√ÅO THAY ƒê·ªîI GI√Å B·∫†C*\n\n"
                        f"{emoji} *{main_product}*\n"
                        f"üìä C≈©: {self.format_price(last)} VND\n"
                        f"üìä M·ªõi: {self.format_price(cur)} VND\n"
                        f"üìà Bi·∫øn ƒë·ªông: {'+' if delta>0 else ''}{self.format_price(delta)} VND ({(delta/last*100):+.2f}%)\n\n"
                        f"üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}"
                    )
                    await self.send_to_group(msg)
                    # G·ª≠i subscribers
                    for uid in self.subscribers.copy():
                        try:
                            await self.application.bot.send_message(uid, msg, parse_mode="Markdown")
                        except Exception:
                            self.subscribers.discard(uid)

    async def check_scheduled_updates(self, prices: Dict):
        """G·ª≠i ƒë·ªãnh k·ª≥ g·∫ßn c√°c m·ªëc 08:30, 12:00, 16:00 (¬±2 ph√∫t)."""
        now = datetime.now(VN_TZ)
        target = [(8, 30), (12, 0), (16, 0)]
        for hh, mm in target:
            if abs((now.hour * 60 + now.minute) - (hh * 60 + mm)) <= 2:
                await self.send_scheduled_update(prices)
                break

    async def send_scheduled_update(self, prices: Dict):
        """N·ªôi dung c·∫≠p nh·∫≠t ƒë·ªãnh k·ª≥ (c√≥ spread)."""
        lines = ["üîî *C·∫¨P NH·∫¨T GI√Å B·∫†C ƒê·ªäNH K·ª≤*\n"]
        main_products = [
            "B·∫†C MI·∫æNG PH√ö QU√ù 999 1 L∆Ø·ª¢NG",
            "B·∫†C TH·ªéI PH√ö QU√ù 999 10 L∆Ø·ª¢NG, 5 L∆Ø·ª¢NG",
        ]
        for name in main_products:
            if name in prices:
                d = prices[name]
                lines.append(f"üî∏ *{name}*")
                lines.append(f"   üíµ Mua: {self.format_price(d['buy_price'])} VND")
                if d["sell_price"]:
                    lines.append(f"   üí¥ B√°n: {self.format_price(d['sell_price'])} VND")
                    sp, pct = self.calculate_spread(d["buy_price"], d["sell_price"])
                    lines.append(f"   üìä Ch√™nh l·ªách: {self.format_price(sp)} VND ({pct:.2f}%)")
                lines.append("")

        # Bi·∫øn ƒë·ªông so v·ªõi l·∫ßn l∆∞u g·∫ßn nh·∫•t
        base = "B·∫†C MI·∫æNG PH√ö QU√ù 999 1 L∆Ø·ª¢NG"
        if base in prices and base in self.last_prices:
            cur = prices[base]["buy_price"]
            last = self.last_prices[base]["buy_price"]
            if last > 0:
                delta = cur - last
                pct = delta / last * 100
                if abs(pct) >= 0.1:
                    emoji = "üìà" if delta > 0 else "üìâ" if delta < 0 else "‚û°Ô∏è"
                    lines.append(f"{emoji} *Bi·∫øn ƒë·ªông:* {'+' if delta>0 else ''}{self.format_price(delta)} VND ({pct:+.2f}%)\n")

        lines.append(f"üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}")
        lines.append("üåê *Ngu·ªìn:* giabac.phuquygroup.vn")

        await self.send_to_group("\n".join(lines))


# ========= Kh·ªüi t·∫°o bot =========
bot = SilverPriceBot()

# ========= Handlers =========
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = (
        "üè¶ *Ch√†o m·ª´ng ƒë·∫øn v·ªõi Bot Gi√° B·∫°c!*\n\n"
        "üìã *L·ªánh:*\n"
        "‚Ä¢ /price - Gi√° hi·ªán t·∫°i\n"
        "‚Ä¢ /history - L·ªãch s·ª≠ 24h\n"
        "‚Ä¢ /subscribe - ƒêƒÉng k√Ω th√¥ng b√°o\n"
        "‚Ä¢ /unsubscribe - H·ªßy ƒëƒÉng k√Ω\n"
        "‚Ä¢ /status - Tr·∫°ng th√°i bot\n\n"
        "üîÑ *T·ª± ƒë·ªông:*\n"
        "‚Ä¢ 08:30, 12:00, 16:00\n"
        "‚Ä¢ C·∫£nh b√°o thay ƒë·ªïi > 2%"
    )
    keyboard = [
        [InlineKeyboardButton("üìà Gi√° hi·ªán t·∫°i", callback_data="price"),
         InlineKeyboardButton("üìä Ch√™nh l·ªách", callback_data="spread")],
        [InlineKeyboardButton("üîî ƒêƒÉng k√Ω", callback_data="subscribe"),
         InlineKeyboardButton("üìö L·ªãch s·ª≠", callback_data="history")],
    ]
    await update.message.reply_text(txt, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))

async def cmd_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üîÑ ƒêang l·∫•y gi√°...")
    prices = await bot.fetch_silver_prices()
    if not prices:
        await update.message.reply_text("‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu.")
        return

    lines = ["üí∞ *GI√Å B·∫†C HI·ªÜN T·∫†I*\n"]
    for product, d in prices.items():
        sp, pct = bot.calculate_spread(d["buy_price"], d["sell_price"])
        lines.append(f"üî∏ *{product}*")
        lines.append(f"   üíµ Mua: {bot.format_price(d['buy_price'])} VND")
        if d["sell_price"]:
            lines.append(f"   üí¥ B√°n: {bot.format_price(d['sell_price'])} VND")
            lines.append(f"   üìä Ch√™nh l·ªách: {bot.format_price(sp)} VND ({pct:.2f}%)")
        lines.append("")
    lines.append(f"üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}")
    await update.message.reply_text("\n".join(lines), parse_mode="Markdown")

async def cmd_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not bot.price_history:
        await update.message.reply_text("üì≠ Ch∆∞a c√≥ l·ªãch s·ª≠.")
        return
    last = bot.price_history[-1]
    ts = last["timestamp"].strftime("%H:%M %d/%m/%Y")
    await update.message.reply_text(f"üìö Hi·ªán l∆∞u {len(bot.price_history)} b·∫£n ghi. B·∫£n g·∫ßn nh·∫•t: {ts}")

async def cmd_sub(update: Update, context: ContextTypes.DEFAULT_TYPE):
    bot.subscribers.add(update.effective_user.id)
    await update.message.reply_text("üîî ƒê√£ ƒëƒÉng k√Ω th√¥ng b√°o!")

async def cmd_unsub(update: Update, context: ContextTypes.DEFAULT_TYPE):
    bot.subscribers.discard(update.effective_user.id)
    await update.message.reply_text("üîï ƒê√£ h·ªßy ƒëƒÉng k√Ω.")

async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = (
        f"ü§ñ *TR·∫†NG TH√ÅI*\n\n"
        f"üìä History: {len(bot.price_history)}\n"
        f"üë• Subs: {len(bot.subscribers)}\n"
        f"üïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}\n"
        f"üåê Railway (PORT={PORT})"
    )
    await update.message.reply_text(txt, parse_mode="Markdown")

async def on_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    if q.data == "price":
        await q.edit_message_text("üîÑ ƒêang l·∫•y gi√°...")
        prices = await bot.fetch_silver_prices()
        if prices:
            base = "B·∫†C MI·∫æNG PH√ö QU√ù 999 1 L∆Ø·ª¢NG"
            if base in prices:
                d = prices[base]
                sp, pct = bot.calculate_spread(d["buy_price"], d["sell_price"])
                msg = (
                    "üí∞ *GI√Å B·∫†C HI·ªÜN T·∫†I*\n\n"
                    f"üî∏ *{base}*\n"
                    f"üíµ Mua: {bot.format_price(d['buy_price'])} VND\n"
                    + (f"üí¥ B√°n: {bot.format_price(d['sell_price'])} VND\n" if d["sell_price"] else "")
                    + (f"üìä Ch√™nh l·ªách: {bot.format_price(sp)} VND ({pct:.2f}%)\n" if d["sell_price"] else "")
                    + f"\nüïê {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}"
                )
                await q.edit_message_text(msg, parse_mode="Markdown")
            else:
                await q.edit_message_text("Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ch√≠nh.")
        else:
            await q.edit_message_text("‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu.")
    elif q.data == "subscribe":
        bot.subscribers.add(q.from_user.id)
        await q.edit_message_text("üîî ƒê√£ ƒëƒÉng k√Ω th√¥ng b√°o!")
    elif q.data == "history":
        await q.edit_message_text(f"üìö S·ªë b·∫£n ghi: {len(bot.price_history)}")
    elif q.data == "spread":
        prices = await bot.fetch_silver_prices()
        if not prices:
            await q.edit_message_text("‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu.")
            return
        lines = ["üìä *B·∫¢NG CH√äNH L·ªÜCH (m·∫´u)*\n"]
        for product, d in list(prices.items())[:5]:
            sp, pct = bot.calculate_spread(d["buy_price"], d["sell_price"])
            lines.append(f"‚Ä¢ {product}: {bot.format_price(sp)} VND ({pct:.2f}%)")
        await q.edit_message_text("\n".join(lines), parse_mode="Markdown")

# ========= Health server =========
from aiohttp import web

async def _health(request):
    return web.Response(
        text=(
            "ü§ñ Silver Price Bot is running!\n"
            f"‚è∞ {datetime.now(VN_TZ).strftime('%H:%M %d/%m/%Y')}\n"
            f"üìä History: {len(bot.price_history)}\n"
            f"üë• Subs: {len(bot.subscribers)}"
        )
    )

async def start_health_server():
    app = web.Application()
    app.router.add_get("/", _health)
    app.router.add_get("/health", _health)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", PORT)
    await site.start()
    logger.info("üåê Health server started on port %s", PORT)

# ========= main =========
async def main():
    # Lu√¥n b·∫≠t health server tr∆∞·ªõc ƒë·ªÉ Railway kh√¥ng 503
    await start_health_server()
    logger.info("üåê Health server started on port %s", PORT)

    # N·∫øu thi·∫øu BOT_TOKEN, v·∫´n treo app ƒë·ªÉ /health s·ªëng
    if not BOT_TOKEN or BOT_TOKEN == "YOUR_BOT_TOKEN_HERE":
        logger.error("‚ùå Ch∆∞a c·∫•u h√¨nh BOT_TOKEN! Ch·ªâ ch·∫°y /health.")
        try:
            await asyncio.Future()  # run forever
        except asyncio.CancelledError:
            return

    # T·∫°o Telegram Application
    application = Application.builder().token(BOT_TOKEN).build()
    bot.application = application

    # Handlers
    application.add_handler(CommandHandler("start", cmd_start))
    application.add_handler(CommandHandler("price", cmd_price))
    application.add_handler(CommandHandler("history", cmd_history))
    application.add_handler(CommandHandler("subscribe", cmd_sub))
    application.add_handler(CommandHandler("unsubscribe", cmd_unsub))
    application.add_handler(CommandHandler("status", cmd_status))
    application.add_handler(CallbackQueryHandler(on_button))

    # Monitoring background
    bot.monitoring_task = asyncio.create_task(bot.price_monitoring_loop())

    logger.info("ü§ñ Bot Gi√° B·∫°c kh·ªüi ƒë·ªông (polling)...")

    # ‚úÖ Tr√¨nh t·ª± async ƒë√∫ng (kh√¥ng d√πng run_polling trong event loop)
    await application.initialize()
    await application.start()
    await application.updater.start_polling(drop_pending_updates=True)

    try:
        await asyncio.Future()  # run forever
    except asyncio.CancelledError:
        pass
    finally:
        await application.updater.stop()
        await application.stop()
        await application.shutdown()

if __name__ == "__main__":
    asyncio.run(main())
